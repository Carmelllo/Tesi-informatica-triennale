\chapter{Metodologie di sviluppo del software}
\label{cap:processi-metodologie}

\intro{In questo capitolo viene descritto l'approccio organizzativo adottato per lo stage e come viene pianificato e verificato il lavoro su base settimanale.}

\section{Metodologia adottata}
\label{sec:metodologia-adottata}

Per lo svolgimento del progetto è stata adottata una metodologia \textbf{iterativo-incrementale} con \textbf{\emph{timebox} settimanale}. Il tracciamento avviene tramite un elenco di \emph{obiettivi settimanali}, derivati dalla pianificazione riportata nel Capitolo~\ref{cap:descrizione-stage} (sezione Pianificazione).
\figure[!h]
    \centering

    \includegraphics[width=1\columnwidth]{IID-diagramma.png}
    \caption{Modello di sviluppo iterativo-incrementale}
\endfigure

\section{Introduzione al modello di sviluppo iterativo-incrementale}
\subsection{Introduzione}
Lo sviluppo iterativo-incrementale consiste nel miglioramento continuo del prodotto attraverso cicli ripetuti aggiungendo gradualmente nuove funzionalità a ogni ciclo. Questo approccio consente di adattarsi rapidamente ai cambiamenti dei requisiti e di integrare il \emph{feedback} degli \emph{stakeholder} in modo tempestivo, migliorando la qualità complessiva del prodotto finale.
\subsection{Origine}
Molti esempi di impiego precoce sono riportati nell'articolo di Craig Larman e Victor Basili "Iterative and Incremental Development: A Brief History" \cite{LarmanBasili2003}, tra i quali uno dei più antichi è il Project Mercury della NASA negli anni '60. Alcuni ingegneri coinvolti in Mercury formarono successivamente una divisione dentro IBM; un esempio notevole di successo nell'uso di \gls{iid}\glsfirstoccur in quel contesto fu lo sviluppo del \emph{software} avionico principale dello Space Shuttle, realizzato tra il 1977 e il 1980 tramite 17 iterazioni in 31 mesi.

Organizzazioni come il Dipartimento della Difesa degli Stati Uniti hanno mostrato una preferenza per metodologie iterative e la \gls{dod}\glsfirstoccur del 2000 esponeva chiaramente una preferenza per un approccio evolutivo/iterativo alla realizzazione delle capacità \emph{software}: "An evolutionary approach is preferred...". Le revisioni successive di DoDI 5000.02 non menzionano più esplicitamente lo "\emph{spiral development}", ma sostengono comunque l'approccio iterativo come \emph{baseline} per programmi \emph{software}-intensive.

Anche agenzie di sviluppo internazionale, come la United States Agency for International Development (USAID), adottano un approccio iterativo e incrementale nel ciclo di programmazione per progettare, monitorare, valutare, apprendere e adattare i progetti, privilegiando collaborazione, apprendimento e adattamento continuo.

\subsection{Fasi del modello di sviluppo iterativo-incrementale}
Il modello iterativo-incrementale si articola in diverse fasi principali:
\begin{itemize}
\item \textbf {Inception}: identifica l'ambito del progetto, i requisiti (funzionali e non funzionali) e i rischi a un livello elevato, ma con dettagli sufficienti affinché il lavoro possa essere stimato. In questa fase si definiscono il \emph{business case}, gli \emph{stakeholder} principali, gli obiettivi di alto livello e i vincoli di progetto; si produce un \emph{backlog} iniziale e si effettuano stime di massima e una prima analisi dei rischi per decidere il \emph{go/no go}. I \emph{deliverable} tipici includono la \emph{vision}, la lista dei requisiti prioritari, il piano di progetto e il registro dei rischi.
\item \textbf {Elaboration}: fornisce un'architettura funzionante che mitiga i principali rischi e soddisfa i requisiti non funzionali. Comprende la realizzazione di prototipi o \emph{proof of concept} per validare scelte architetturali, la definizione della \emph{baseline} tecnica e delle specifiche non funzionali (\emph{performance}, sicurezza, scalabilità). In questa fase si aggiornano stime e piani, si dettagliano i criteri di accettazione e si prepara il piano di test per garantire la fattibilità tecnica.
\item \textbf {Construction}: riempie progressivamente l'architettura con codice pronto per la produzione, prodotto dall'analisi, progettazione, implementazione e test dei requisiti funzionali. È caratterizzata da iterazioni multiple con sviluppo incrementale, integrazione continua, test automatici e revisioni del codice; ogni iterazione produce incrementi rilasciabili, documentazione tecnica aggiornata e attività di \emph{refactoring} per mantenere la qualità del codice.
\item \textbf {Transition}: consegna il sistema nell'ambiente operativo di produzione. Include le attività di \emph{deploy} e migrazione dati, le operazioni di \emph{training} per gli utenti finali e il supporto iniziale post rilascio, il monitoraggio delle prestazioni e la raccolta dei \emph{feedback} per eventuali correzioni. I \emph{deliverable} finali comprendono la documentazione utente, la documentazione di \emph{deployment}, il registro delle \emph{issue} risolte e il verbale di \emph{acceptance/sign off}.
\end{itemize}

\section{Applicazione del modello iterativo-incrementale nel progetto}
\subsection{Motivazioni della scelta}
La scelta del modello iterativo-incrementale per lo svolgimento del progetto di \emph{stage} è stata immediata e naturale dato che i tutor aziendali adottano tale metodologia con la quale è iniziato lo sviluppo sin dalla prima settimana. IID è particolarmente adatto a contesti in cui i requisiti possono evolvere rapidamente e dove è fondamentale integrare il \emph{feedback} degli utenti in modo continuo. Poiché il caso di studio del progetto è in continua evoluzione e sviluppo, l'approccio iterativo-incrementale consente di adattarsi rapidamente ai cambiamenti e di migliorare costantemente il prodotto finale.

\subsection{Confronto con altre metodologie}
La metodologia iterativo-incrementale è stata preferita rispetto ad altre alternative per le seguenti ragioni:
\begin{itemize}
    \item \textbf{\emph{Waterfall}}: il modello a cascata prevede fasi sequenziali rigide (analisi, progettazione, implementazione, test, rilascio) senza possibilità di tornare indietro. Questo approccio non era adatto al progetto di \emph{stage} poiché i requisiti relativi al \emph{testing} di LLM sono in continua evoluzione e richiedono frequenti adattamenti basati sui risultati ottenuti;
    \item \textbf{\emph{Scrum} puro}: sebbene \emph{Scrum} sia una metodologia agile molto diffusa, la sua implementazione completa (con \emph{daily standup}, \emph{Sprint} di durata fissa, ruoli definiti come \emph{Scrum Master} e \emph{Product Owner}) risultava sovradimensionata per un progetto individuale di \emph{stage}. Si è quindi optato per un approccio più snello che mantiene i principi iterativi senza l'\emph{overhead} organizzativo di \emph{Scrum};
    \item \textbf{\emph{Kanban}}: pur essendo un metodo flessibile, \emph{Kanban} si concentra sul flusso continuo senza iterazioni definite, rendendo più difficile la pianificazione e la verifica periodica degli obiettivi con il tutor aziendale.
\end{itemize}

\subsection{Metodologia operativa adottata}

La cadenza operativa prevede:
\begin{description}
    \item[Allineamento settimanale] un unico incontro (30/45 minuti) che combina \emph{review} breve dei risultati ottenuti e \emph{planning} della settimana successiva; durante l'incontro si definisce esplicitamente il \textbf{\emph{goal} della settimana}. L'agenda tipica comprende stato degli obiettivi, rischi/impedimenti incontrati, decisioni da prendere e pianificazione dei prossimi passi. L'esito atteso è un \emph{goal} chiaro, con criteri di accettazione condivisi e una stima realistica in base alla capacità disponibile; se emergono dipendenze o ostacoli, si pianifica subito come rimuoverli o si riduce il perimetro mantenendo il \emph{timebox}.
    \item[Supporto] durante la settimana, il tutor aziendale fornisce supporto per sblocchi tecnici e decisioni operative quando necessario. Il confronto avviene tramite brevi sincronizzazioni giornaliere tramite la piattaforma \gls{slack}\glsfirstoccur dove ogni giorno si discute su quello che è stato fatto in modo tale da mantenere un allineamento costante e reindirizzare il lavoro se necessario.
    \item[Incremento] ogni \emph{timebox} produce un risultato verificabile (es. \emph{script}/\emph{report}, esiti di test su codice reale, componente di \emph{dashboard}, documentazione), tutto ciò viene mostrato al tutor durante l'allineamento settimanale successivo per raccogliere \emph{feedback} e pianificare i passi successivi.
\end{description}

La misura dell'avanzamento è basata sul raggiungimento dei \emph{goal settimanali}. Questo approccio consente di ridurre il rischio, incorporare rapidamente i \emph{feedback} e mantenere la tracciabilità rispetto alla conformità OWASP. 
In caso di scostamenti si adatta il perimetro mantenendo fisso il \emph{timebox}, privilegiando il soddisfacimento dei requisiti obbligatori. 

\subsection{Esempio di iterazione settimanale}
Di seguito viene riportato un esempio rappresentativo di come si è svolta una tipica iterazione settimanale durante il progetto di \emph{stage}.

\begin{table}[htbp]
\centering
\caption{Esempio di iterazione settimanale}
\label{tab:esempio-iterazione}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\textbf{Elemento} & \textbf{Descrizione} \\
\hline
\textbf{Settimana} & [Numero settimana, es. Settimana 3] \\
\hline
\textbf{\emph{Goal}} & [Obiettivo principale della settimana, es. ``Implementare il modulo di \emph{testing} per \emph{prompt injection}''] \\
\hline
\textbf{Attività pianificate} & 
1) [Attività 1, es. Analisi dei \emph{dataset} esistenti] \newline
2) [Attività 2, es. Sviluppo dello \emph{script} di \emph{testing}] \newline
3) [Attività 3, es. Esecuzione test su modello target] \\
\hline
\textbf{\emph{Deliverable}} & [Output atteso, es. \emph{Report} con risultati dei test e analisi delle vulnerabilità rilevate] \\
\hline
\textbf{Impedimenti} & [Eventuali ostacoli incontrati, es. Limite di \emph{rate} delle API del modello] \\
\hline
\textbf{Esito} & [Risultato finale, es. \emph{Goal} raggiunto / Parzialmente raggiunto / Non raggiunto] \\
\hline
\textbf{\emph{Feedback} tutor} & [Note e suggerimenti ricevuti durante la \emph{review}] \\
\hline
\end{tabularx}
\end{table}

Questo \emph{template} è stato utilizzato come traccia per documentare ogni iterazione, garantendo coerenza nella reportistica e facilitando il confronto tra settimane successive. 
